# 多端协作同步影响分析

> **版本**: 1.0  
> **日期**: 2024-12-24  
> **范围**: 富节点 UI 重构对 Yjs 同步的影响评估

---

## 一、核心发现总结

### ✅ 低风险项
1. **数据结构兼容** - `YjsNodeData` 已预留扩展字段
2. **同步机制无变更** - 仍使用 `GraphSyncManager` 双向同步
3. **UI层隔离** - 视觉变更不影响 Yjs 数据模型

### ⚠️ 中风险项
1. **频繁的 Data Changes** - 每次 UI 状态变更可能触发同步
2. **编辑状态冲突** - 多用户同时编辑同一节点
3. **性能影响** - 复杂节点渲染 + 频繁同步消息

### 🔴 需注意事项
1. **UI-Only 字段** - `isEditing`、`isSelected` 不应同步
2. **高度缓存失效** - 远程更新时缓存需刷新
3. **向后兼容** - 旧客户端能否正确渲染新节点

---

## 二、数据结构影响分析

### 2.1 现有 Yjs 数据结构

```typescript
export interface YjsNodeData {
  // 基础字段
  id: string;
  x: number;
  y: number;
  label: string;
  
  // 节点类型
  nodeType?: NodeType;  // ✅ 已支持
  props?: TaskProps | RequirementProps | PBSProps | DataProps;  // ✅ 已支持
  
  // 其他字段
  tags?: string[];
  isArchived?: boolean;
  parentId?: string;
  // ...
}
```

**结论**: ✅ **现有数据结构完全支持富节点 UI**，无需变更。

### 2.2 派生数据 vs 存储数据

| 类型 | 示例 | 存储位置 | 同步 |
|:---|:---|:---|:---|
| **存储数据** | `label`, `nodeType`, `props` | Yjs `yNodes` | ✅ 同步 |
| **派生数据** | Header 颜色, 图标, 指标格式化 | 客户端计算 | ❌ 不同步 |
| **UI-Only** | `isEditing`, `isSelected` | React state | ❌ 不同步 |

**最佳实践**:
```typescript
// ✅ 正确: 从 node.data 派生
const headerColor = NODE_RENDERERS[data.nodeType].getHeaderColor();

// ❌ 错误: 将派生数据存入 Yjs
node.setData({ headerColor: '#1E3A8A' }); // 不要这样做
```

---

## 三、同步频率与性能影响

### 3.1 触发同步的操作

| 操作 | 现有频率 | 富节点 UI 频率 | 影响 |
|:---|:---|:---|:---|
| **标题编辑** | 每次提交 | 每次提交 | 🟢 无变化 |
| **节点拖拽** | 每次移动 | 每次移动 | 🟢 无变化 |
| **类型转换** | 1次 | 1次 | 🟢 无变化 |
| **Props 更新** | 1次 | **可能多次** | 🟡 需优化 |

**潜在问题**: 如果 `MetricsRow` 实现为可编辑字段（如进度条拖拽），每次变更都会触发 `node:change:data`。

**缓解措施**:
```typescript
// 使用防抖避免过度同步
const debouncedUpdate = useMemo(
  () => debounce((nodeId: string, props: any) => {
    updateNodeProps(nodeId, nodeType, props);
  }, 300),  // 300ms 防抖
  []
);
```

### 3.2 渲染性能与同步耦合

**现状**: `GraphSyncManager.applyNodeToGraph()` 中，每次远程更新都会调用 `node.setData(..., { overwrite: true })`，触发 `node:change:data` → 重新渲染。

```typescript
// GraphSyncManager.ts L497-514
existingNode.setData({
  label: data.label,
  nodeType: data.nodeType,
  props: data.props,  // ← 每次远程更新都会覆盖
  // ...
}, { overwrite: true });
```

**富节点 UI 新增风险**:
- 复杂的 `RichNodeLayout` 可能导致每次 `setData` 耗时 > 10ms
- 100 个节点同时更新 → 总耗时 > 1000ms → **卡顿**

**缓解措施**:
1. **React.memo**: 确保仅在相关 props 变更时重新渲染
2. **高度缓存**: 避免每次 `setData` 都重新计算高度
3. **批量更新**: Yjs 的 `transact` 已经支持，但需验证是否生效

---

## 四、编辑状态冲突处理

### 4.1 问题场景

**场景**: 用户 A 和用户 B 同时双击编辑同一节点

| 时间 | 用户 A | 用户 B | Yjs 状态 |
|:---|:---|:---|:---|
| T0 | 双击节点 1 | - | `isEditing: false` |
| T1 | `isEditing: true` | - | - |
| T2 | - | 双击节点 1 | - |
| T3 | - | `isEditing: true` | - |
| T4 | 输入 "New Title A" | 输入 "New Title B"| ❓ |
| T5 | 按 Enter 提交 | - | `label: "New Title A"` |
| T6 | - |按 Enter 提交 | `label: "New Title B"` |

**结果**: **Last Write Wins** - B 的标题覆盖 A 的标题。

### 4.2 当前机制

**好消息**: `isEditing` **未同步到 Yjs**（L229-240 的防护）

```typescript
// GraphSyncManager.ts L238-240
if (event.transaction.origin === LOCAL_ORIGIN) {
  logger.debug('yNodes.observe: skipping local UI transaction');
  return;  // ← 不处理本地事务
}
```

**坏消息**: 标题最终提交仍会冲突（Yjs CRDT 的 Last Write Wins）。

### 4.3 解决方案

**方案 A: 编辑锁（推荐）**
```typescript
// 扩展 YjsNodeData
export interface YjsNodeData {
  // ...
  editingBy?: string;  // 当前编辑用户 ID
  editingAt?: string;  // 开始编辑时间
}
```

逻辑:
1. 用户 A 双击 → 写入 `editingBy: 'user-a'`
2. 用户 B 双击 → 检测到已锁定 → 显示 Toast: "节点正在被 Alice 编辑"
3. 用户 A 提交/取消 → 清除 `editingBy`

**方案 B: 冲突通知（轻量）**
- 不阻止编辑，但在提交时检测冲突
- 如果检测到 `updatedAt` 晚于本地编辑开始时间 → Toast: "内容已被他人更新，请刷新"

---

## 五、向后兼容性

### 5.1 问题

**场景**: 旧客户端（未升级）接收到新客户端发送的富节点数据

```typescript
// 新客户端 (Rich Node UI)
yNodes.set('node-1', {
  id: 'node-1',
  label: 'Zephir Project',
  nodeType: NodeType.PBS,
  props: { taskCount: 5, riskCount: 2, progress: 0.6 },
  // ...
});

// 旧客户端接收到数据
const data = yNodes.get('node-1');
// ❓ 能否正确渲染?
```

### 5.2 兼容性分析

| 字段 | 旧客户端行为 | 影响 |
|:---|:---|:---|
| `nodeType` | 忽略或显示为普通节点 | 🟡 可接受 |
| `props.taskCount` | 不显示 | 🟡 可接受 |
| `label` | 正常显示 | 🟢 无影响 |
| `x`, `y` | 正常定位 | 🟢 无影响 |

**结论**: ✅ **向后兼容性良好**，旧客户端最多丢失视觉信息，不会崩溃。

---

## 六、风险缓解建议

| 风险项 | 严重度 | 缓解措施 | 优先级 |
|:---|:---|:---|:---|
| 频繁 Props 更新导致同步风暴 | 🟡 中 | 所有可编辑字段使用 300ms 防抖 | **P0** |
| 多用户编辑冲突 | 🟡 中 | 实现编辑锁机制（Phase 2） | P1 |
| 远程更新导致缓存失效 | 🟡 中 | 高度缓存增加版本号，远程更新清除 | **P0** |
| 复杂节点渲染性能 | 🟢 低 | React.memo + 虚拟化 | P1 |

---

## 七、测试建议

### 7.1 多端同步测试用例

| 测试项 | 操作 | 预期结果 |
|:---|:---|:---|
| **基础同步** | 用户A创建PBS节点 | 用户B立即看到蓝色Header |
| **编辑同步** | 用户A修改标题 | 用户B实时更新标题 |
| **Props同步** | 用户A更新进度条 | 用户B看到进度条变化 |
| **编辑冲突** | AB同时编辑同一节点 | 后提交者胜出（记录日志）|
| **性能** | 用户A批量创建100个节点 | 用户B加载耗时 < 500ms |

### 7.2 性能基准测试

```typescript
// 测试代码
const yNodes = yDoc.getMap('nodes');
const startTime = performance.now();

// 模拟远程批量更新
yDoc.transact(() => {
  for (let i = 0; i < 100; i++) {
    yNodes.set(`node-${i}`, {
      id: `node-${i}`,
      label: `Node ${i}`,
      nodeType: NodeType.PBS,
      x: i * 300,
      y: 100,
      // ...
    });
  }
});

const duration = performance.now() - startTime;
expect(duration).toBeLessThan(500);  // < 500ms
```

---

## 八、实施要点

### 阶段 1: MVP (无同步变更)
- [x] 使用现有 `YjsNodeData` 结构
- [x] 确保 UI-Only 字段不同步
- [ ] 添加性能监控埋点
- [ ] 多端同步测试用例

### 阶段 2: 优化 (可选)
- [ ] 实现编辑锁机制
- [ ] 高度缓存版本化
- [ ] 虚拟化渲染 (> 100 节点)

---

## 九、结论

### ✅ **总体评估: 低风险**

富节点 UI 重构对多端同步的影响**可控**，主要原因：
1. 数据结构无需变更
2. 视觉派生数据不进入 Yjs
3. 现有同步机制已经健壮

### ⚠️ **需注意的关键点**

1. **防抖所有可编辑字段** (300ms)
2. **React.memo 所有子组件**
3. **高度缓存需处理远程更新**
4. **记录多端测试用例**（见第七节）

### 📋 **额外工作量评估**

- **0 天** - 数据结构变更
- **0.5 天** - 防抖优化
- **1 天** - 多端测试用例
- **合计**: **1.5 天**（已在 Phase 1 MVP 中）
